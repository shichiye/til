# 索引面试题

索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。

## 索引的分类

### 按数据结构分类

从数据结构的角度来说，MySQL常见的索引有 `B+Tree 索引`、`Hash 索引`和`Full-Text索引`。

![](https://scy-1259328723.cos.ap-nanjing.myqcloud.com/pic/20220708204755.png)

`InnoDB` 是在 `MySQL5.5` 之后成为默认的存储引擎，所以 `B+Tree 索引` 也是MySQL存储引擎采用的最多的索引。

在创建表时，`InnoDB` 存储引擎会根据不同的情况选择不同的列作为索引：
* 如果有主键，默认会使用主键作为聚簇索引的索引键
* 如果没有主键，就选择第一个不包含 `Null` 值的唯一列作为聚簇索引的索引键
* 在上面两个都没有的情况下，将自动生成一个隐式自增id列作为聚簇索引的索引键

其他索引都属于辅助索引（Secondary Index），也被称为二级索引和非聚簇索引。

默认创建的主键索引和二级索引默认使用的都是 `B+Tree 索引`

`B+Tree 索引` 存储千万级的数据只需要3-4层高度就可以满足，意味着从千万级的表查询目标数据最多需要3-4次磁盘I/O，所以 `B+Tree 索引` 相比于 `B树` 和 `二叉树` 来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况下，查询一个数据的磁盘I/O次数依旧维持在3/4次

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

* 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
* 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

使用二级索引查询，如果要获取整行数据，则需要进行 `回表` 操作，也就是需要查询两个 `B+Tree 索引` 才能查到数据。不过，当查询的数据是能在二级索引的 `B+Tree 索引` 的叶子节点中查询到的，就不用再查询主键索引，比如说只查询id值，这个过程也叫做 `覆盖索引`，只用查一次 `B+Tree 索引`

### 按物理存储分类

从物理存储来看，索引分为聚簇索引（主键索引）和二级索引（辅助索引）。

### 按字段特性分类

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引和前缀索引。

#### 主键索引

主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

```SQL
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

#### 唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值

```SQL
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建唯一索引，可以使用这面这条命令：

```SQL
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...);
```

#### 普通索引

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

```SQL
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建普通索引，可以使用这面这条命令：

```SQL
CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

#### 前缀索引

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

```SQL
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

建表后，如果要创建前缀索引，可以使用这面这条命令：

```SQL
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

### 按字段个数分类

从字段个数的角度来看，索引分为单列索引、联合索引。

#### 联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。比如将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)，创建联合索引的方式如下：

```SQL
CREATE INDEX index_product_no_name ON product(product_no, name);
```

联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。

现在我们知道，对于联合索引（a, b），在执行 select * from table where a > 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

* 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。

* 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。


## 有什么优化索引的方法？

* 前缀索引优化
* 覆盖索引优化
* 主键索引最好是自增的
* 防止索引失效

### 前缀索引优化

前缀索引就是使用某个字段中前几个字符建立索引。

使用前缀索引是为了减小索引字段大小，可以增加一个索引页中的存储的索引值，提高索引的查询速度。

不过，前缀索引有一定的局限性
1. order by 无法使用前缀索引
2. 无法把前缀索引用作覆盖索引

### 覆盖索引优化

覆盖索引是指SQL中query的所有字段，在索引的B+Tree的叶子节点上都能找得到的那些索引，从二级索引能查询到记录，而不需要通过聚簇索引查询获得，避免回表操作。

覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少大量的I/O操作。

### 主键索引最好是自增的

### 索引最好设置为 NOT NULL

### 防止索引失效
